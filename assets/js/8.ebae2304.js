(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{360:function(v,t,_){"use strict";_.r(t);var a=_(42),s=Object(a.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"javascript执行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript执行机制"}},[v._v("#")]),v._v(" JavaScript执行机制")]),v._v(" "),_("h2",{attrs:{id:"执行顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行顺序"}},[v._v("#")]),v._v(" 执行顺序")]),v._v(" "),_("h3",{attrs:{id:"编译阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编译阶段"}},[v._v("#")]),v._v(" 编译阶段")]),v._v(" "),_("ul",[_("li",[v._v("变量提升\n"),_("ul",[_("li",[v._v("JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头。")]),v._v(" "),_("li",[v._v("变量的默认值设置为undefined")])])]),v._v(" "),_("li",[v._v("经过编译后，会生成两部分内容：执行上下文和可执行代码")])]),v._v(" "),_("h3",{attrs:{id:"执行阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行阶段"}},[v._v("#")]),v._v(" 执行阶段")]),v._v(" "),_("ul",[_("li",[v._v("JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行")])]),v._v(" "),_("h3",{attrs:{id:"同名优先级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#同名优先级"}},[v._v("#")]),v._v(" 同名优先级")]),v._v(" "),_("ul",[_("li",[v._v("同名的函数，JavaScript编译阶段会选择最后声明。")]),v._v(" "),_("li",[v._v("变量和函数同名，那么在编译阶段，变量的声明会被忽略")])]),v._v(" "),_("h2",{attrs:{id:"执行上下文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[v._v("#")]),v._v(" 执行上下文")]),v._v(" "),_("ul",[_("li",[v._v("当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在\n整个页面的生存周期内，全局执行上下文只有一份。")]),v._v(" "),_("li",[v._v("当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况\n下，函数执行结束之后，创建的函数执行上下文会被销毁。")]),v._v(" "),_("li",[v._v("当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。")])]),v._v(" "),_("h2",{attrs:{id:"调用栈"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#调用栈"}},[v._v("#")]),v._v(" 调用栈")]),v._v(" "),_("p",[v._v("JavaScript 引擎正是利用栈的结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，"),_("strong",[v._v("后进先出")]),v._v("的规则，也可以叫"),_("strong",[v._v("执行上下文栈")])]),v._v(" "),_("ul",[_("li",[v._v("每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用\n栈，然后 JavaScript 引擎开始执行函数代码。")]),v._v(" "),_("li",[v._v("如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行\n上下文，并将 B 函数的执行上下文压入栈顶。")]),v._v(" "),_("li",[v._v("当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。")]),v._v(" "),_("li",[v._v("当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。")])]),v._v(" "),_("h3",{attrs:{id:"栈溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈溢出"}},[v._v("#")]),v._v(" 栈溢出")]),v._v(" "),_("p",[v._v("调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错")]),v._v(" "),_("h2",{attrs:{id:"块级作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[v._v("#")]),v._v(" 块级作用域")]),v._v(" "),_("ul",[_("li",[v._v("在程序中定义变量的区域，该位置决定了变量的生命周期。")]),v._v(" "),_("li",[v._v("通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期")]),v._v(" "),_("li",[v._v("使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域")])]),v._v(" "),_("h3",{attrs:{id:"es6之前作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es6之前作用域"}},[v._v("#")]),v._v(" ES6之前作用域")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("全局作用域")]),v._v("中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。")]),v._v(" "),_("li",[_("strong",[v._v("函数作用域")]),v._v("就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被"),_("strong",[v._v("销毁")])])]),v._v(" "),_("h3",{attrs:{id:"变量提升与作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量提升与作用域"}},[v._v("#")]),v._v(" 变量提升与作用域")]),v._v(" "),_("ul",[_("li",[v._v("变量容易在不被察觉的情况下被覆盖掉")]),v._v(" "),_("li",[v._v("本应销毁的变量没有被销毁")])]),v._v(" "),_("h3",{attrs:{id:"es6之后作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es6之后作用域"}},[v._v("#")]),v._v(" ES6之后作用域")]),v._v(" "),_("p",[v._v("JavaScript 引擎支持了变量提升和块级作用域了")]),v._v(" "),_("p",[v._v("块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("编译并创建执行上下文")]),v._v(" "),_("ul",[_("li",[v._v("函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。")]),v._v(" "),_("li",[v._v("通过 let 声明的变量，在编译阶段会被存放到词法环境中。")]),v._v(" "),_("li",[v._v("在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中")])])]),v._v(" "),_("li",[_("p",[v._v("继续执行代码环境")]),v._v(" "),_("ul",[_("li",[v._v("词法环境( let 或者 const 声明的变量)\n"),_("ul",[_("li",[v._v("类似一个小型栈结构，栈底是函数最外层的变量，")]),v._v(" "),_("li",[v._v("进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；")]),v._v(" "),_("li",[v._v("当作用域执行完成之后，该作用域的信息就会从栈顶弹出")])])]),v._v(" "),_("li",[v._v("变量环境\n"),_("ul",[_("li",[v._v("沿着词法环境的栈顶向下查询，")]),v._v(" "),_("li",[v._v("如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，")]),v._v(" "),_("li",[v._v("如果没有查找到，那么继续在变量环境中查找。")])])])])])]),v._v(" "),_("h2",{attrs:{id:"作用域链和闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域链和闭包"}},[v._v("#")]),v._v(" 作用域链和闭包")]),v._v(" "),_("h3",{attrs:{id:"outer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#outer"}},[v._v("#")]),v._v(" outer")]),v._v(" "),_("p",[v._v("每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下 文")]),v._v(" "),_("h3",{attrs:{id:"作用域链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[v._v("#")]),v._v(" 作用域链")]),v._v(" "),_("p",[v._v("函数的 outer 都是指向全局上下文的，这也就意味着如果函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找.查找的链条就称为作用域链。")]),v._v(" "),_("h3",{attrs:{id:"词法作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[v._v("#")]),v._v(" 词法作用域")]),v._v(" "),_("p",[v._v("词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作 用域，通过它就能够预测代码在执行过程中如何查找标识符。")]),v._v(" "),_("p",[v._v("如果函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找")]),v._v(" "),_("p",[v._v("词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系")]),v._v(" "),_("h3",{attrs:{id:"全局作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域"}},[v._v("#")]),v._v(" 全局作用域")]),v._v(" "),_("ul",[_("li",[v._v("首先是在"),_("strong",[v._v("函数")]),v._v("的执行上下文中查找")]),v._v(" "),_("li",[v._v("但因为"),_("strong",[v._v("函数")]),v._v("的执行上下文中没有定义"),_("strong",[v._v("变量")]),v._v("，所以根据词法作用域的规则，")]),v._v(" "),_("li",[v._v("下一步就在"),_("strong",[v._v("函数")]),v._v("的外部作用域中查找")])]),v._v(" "),_("h3",{attrs:{id:"闭包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[v._v("#")]),v._v(" 闭包")]),v._v(" "),_("p",[v._v("在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个 内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存 在内存中，我们就把这些变量的集合称为闭包。")]),v._v(" "),_("p",[v._v("如果该闭包会一直使用，那么它可以作为 全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一 个局部变量。")]),v._v(" "),_("h2",{attrs:{id:"this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[v._v("#")]),v._v(" this")]),v._v(" "),_("h3",{attrs:{id:"全局执行上下文中的-this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全局执行上下文中的-this"}},[v._v("#")]),v._v(" 全局执行上下文中的 this")]),v._v(" "),_("p",[v._v("全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象")]),v._v(" "),_("h3",{attrs:{id:"函数执行上下文中的-this"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数执行上下文中的-this"}},[v._v("#")]),v._v(" 函数执行上下文中的 this")]),v._v(" "),_("p",[v._v("通过函数的 "),_("strong",[v._v("call")]),v._v("和 "),_("strong",[v._v("bind")]),v._v("和"),_("strong",[v._v("apply")]),v._v("方法设置")]),v._v(" "),_("p",[v._v("通过对象调用方法设置")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。")])]),v._v(" "),_("li",[_("p",[v._v("在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。")])]),v._v(" "),_("li",[_("p",[v._v("通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身")])])]),v._v(" "),_("p",[v._v("通过构造函数中设置")]),v._v(" "),_("ol",[_("li",[v._v("创建一个空的简单JavaScript对象（即"),_("code",[v._v("**{}**")]),v._v("）；")]),v._v(" "),_("li",[v._v("链接该对象（设置该对象的"),_("strong",[v._v("constructor")]),v._v("）到另一个对象 ；")]),v._v(" "),_("li",[v._v("将步骤1新创建的对象作为"),_("code",[v._v("**this**")]),v._v("的上下文 ；")]),v._v(" "),_("li",[v._v("如果该函数没有返回对象，则返回"),_("code",[v._v("**this**")]),v._v("。")])]),v._v(" "),_("h3",{attrs:{id:"this-的设计缺陷以及应对方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this-的设计缺陷以及应对方案"}},[v._v("#")]),v._v(" this 的设计缺陷以及应对方案")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("嵌套函数中的 this 不会从外层函数中继承")]),v._v(" "),_("ul",[_("li",[v._v("第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。")]),v._v(" "),_("li",[v._v("第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this")])])]),v._v(" "),_("li",[_("p",[v._v("普通函数中的 this 默认指向全局对象 window")])])]),v._v(" "),_("h3",{attrs:{id:"this避坑"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#this避坑"}},[v._v("#")]),v._v(" this避坑")]),v._v(" "),_("ol",[_("li",[v._v("当函数作为对象的方法调用时，函数中的 this 就是该对象；")]),v._v(" "),_("li",[v._v("当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；")]),v._v(" "),_("li",[v._v("嵌套函数中的 this 不会继承外层函数的 this 值。")]),v._v(" "),_("li",[v._v("箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this")])])])}),[],!1,null,null,null);t.default=s.exports}}]);